This text is targeted for use in an introductory lower-division assembly language programming or computer organization course. After students are introduced to the MIPS architecture using this textbook, they will be well prepared to go on to more advanced courses in computer organization where any modern reduced instruction set computer (RISC) is analyzed. This text provides a technique that will make MIPS assembly language programming a relatively easy task as compared to writing complex Intel™ x86 assembly language code. The skills learned, as a MIPS assembly language programmer, will facilitate learning other more complex assembly languages if the need ever arises. Students using this text will acquire an understanding of how the functional components of modern computers are put together, and how a computer works at the machine language level. It is assumed that students using this text already have some experience in developing algorithms, and running programs in a high-level language.

Chapter 1 provides an introduction to the basic MIPS architecture, which is a modern RISC. 

Chapter 2 shows how to develop code targeted to run on a MIPS processor using an intermediate pseudocode notation similar to the high-level language C. Once an algorithm is specified in this pseudocode notation it is a relatively simple task to translate it to MIPS assembly language. 

Chapter 3 is an introduction to the binary number system. This chapter provides simple procedures for converting values from one number system to another. The rules for performing binary arithmetic are explained. Students will learn how to detect when overflow occurs. 

Chapter 4 explains the features of the PCSpim simulator for the MIPS architecture, which is available for free.

Within the remaining chapters, a wealth of programming exercises are provided that every student needs to become an accomplished assembly language programmer. Instructors are provided with a set of PowerPoint slides. After students have had an opportunity to develop their pseudocode and the corresponding MIPS assembly language code, they can be shown example solutions to each of the exercises via the PowerPoint slides. 

In Chapter 5, students are presented with the classical input/output (I/O) algorithms that involve converting numbers between their integer binary representation and their ASCII decimal and hexadecimal representation. The utility of logical operators and shift operators are stressed.

In Chapter 6, a specific argument-passing protocol is defined. Most significant programming projects are a teamwork effort. Emphasis is placed on the important fact that everyone involved in a teamwork project must adopt the same convention for parameter passing when calling functions. In the case of nested function calls, a specific convention is defined for saving and restoring values in the temporary registers.

In Chapter 7, the necessity for reentrant code is explained, as well as the rules one must follow to write such functions. 

In Chapter 8, students are introduced to memory-mapped I/O. The MIPS simulator provides a memory-mapped I/O feature so that students can gain experience in writing drivers that interface with physical devices. With this PCSpim feature, students can gain experience in writing code to communicate character by character with physical I/O devices. The code that communicates with a physical device at this level is often referred to as a driver. This is a significant advantage of using a simulator to learn assembly language programming. Students learning to write native assembly language typically never have an opportunity to write code that interfaces directly with the I/O devices. These students have to be satisfied with making calls to Basic Input Output System (BIOS) procedures that handle the details of communicating with the I/O devices. Typically these students never experience the real-world challenges that arise as a result of the communication and device time delays.

Chapter 9 introduces exceptions and exception processing. PCSpim responds to interrupts generated by the memorymapped keyboard and display terminal. Given this feature, students have an opportunity to experience writing code to respond to interrupts. Once again this points out the advantage of using a simulator when learning to write assembly language code. Students learning to write assembly language code for their desktop computer typically never have an opportunity to write and run interrupt handlers that enable and disable the interrupt system. Typically these students never experience the real-world challenges that arise in writing the code that resides at the very heart of the operating system.

In Chapter 10 a pipelined implementation of the MIPS architecture is presented, and the special programming considerations dealing with delayed loads and delayed branches are discussed. PCSpim provides an option to run the simulator as if the code were executing on a pipelined implementation of the MIPS architecture. Using this option, students gain experience in writing assembly language code that will run on a pipelined implementation. 

Chapter 11 provides a description of the floating-point features of the MIPS architecture, as well an introduction to the IEEE 754 floating-point standard.

I would like to acknowledge Bary Pollack, James Gips, Doug Milhous, and Dwite Brown who adopted the earlier draft versions of this textbook. I wish to express my special appreciation to Bary Pollack and Tom Fountain for their thorough review of my initial submission to Prentice Hall, and their many constructive recommendations for improvements. The feedback from Seyed H. Hosseini, and Wagdy H. Mahmoud was also quite helpful. I also wish to thank Petra Recter, senior computer science editor, and John Keegan, production editor, both at Prentice Hall, who so effectively managed this project. I am especially grateful to my wife, Jan, for her support and encouragement. She is my true helpmate and soul mate.

